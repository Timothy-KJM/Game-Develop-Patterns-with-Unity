옵저버 패턴
===

01. 개요
<br></br>

* 유니티 개발의 과제는 컴포넌트를 서로 분리하는 좋은 방법을 찾는 것이다.
    + 컴포넌트를 직접 참조하는 다양한 방법을 제공하므로 몇몇 문제가 발생한다.
    + 이런 유연성에는 비용이 발생하고, 참조가 누락되어 코드가 취약해지며 게임 동작에 문제를 일으킨다.
* 옵저버 패턴은 컴포넌트 간 연결의 완전히 제거하는 대신 느슨하게 만들고 논리적으로 구성한다.
* 일대다 구조의 이벤트 처리 시스템을 구축한다.
----------------------------------------------------

02. 옵저버 패턴의 이해
<br></br>

* 목적: 한 객체가 주체 역할, 다른 객체가 관찰자 역할을 맡는 객체 간의 일대다 관계를 설정하는 것이다.
* 주체 역할을 맡는 객체는 내부에서 변경되었을 때 관찰자에게 알리는 책임을 진다.
    + 객체가 특정 이벤트 알림을 구독하고 수신하는 게시자와 구독자의 관계와 유사하다.
* ISubject, IObserver, ConcreteSubject, ConcreteObserver 중 ISubject가 가장 중요하다.
    + AttachObserver(): 알림받을 관찰자 목록에 객체를 추가한다.
    + DetachObserver(): 관찰자 목록에서 관찰자를 제거한다.
    + NotifyObservers(): 주체의 관찰자 목록에 추가된 모든 객체에 알림을 보낸다.
* 관찰자 역할을 맡는 객체는 Notify()라는 공개 메소드를 구현해야만 한다.
    + 이는 주체 객체의 상태가 변경되었을 때 알리고자 사용한다.
----------------------------------------------------

03. 옵저버 패턴의 장단점
<br></br>

* 장점
    + 역동성: 주체에 필요한 만큼의 객체를 관찰자로 추가할 수 있으며, 런타임에 동적으로 제거할 수도 있다.
    + 일대다: 일대다 관계가 있는 객체 간 이벤트 처리 시스템의 구현 문제를 우아하게 해결한다.
* 단점
    + 무질서: 관찰자가 알림을 받는 순서를 보장하지 않는다. 특정 순서에 맞춰야 한다면 이는 부적절하다.
    + 누수: 주체는 관찰자에 대한 강한 참조를 가져 메모리 누수를 일으킬 수도 있다.
----------------------------------------------------

04. 옵저버 패턴을 사용하는 경우
<br></br>

* 객체 간의 일대다 관계와 관련된 특정 문제를 해결하는 경우에서 이점을 보인다.
* 상태를 자주 변경하고 변경 사항에 대응해야 하는 종속성이 많은 핵심 컴포넌트가 있다면 사용한다.
----------------------------------------------------

05. 옵저버 패턴의 구현
<br></br>

* 패턴의 두 가지 요소를 구현하는 것부터 시작한다. Subject 클래스부터 보자.
> Subject.cs
```C#
using UnityEngine;
using System.Collections;

namespace _Observer
{
    public abstract class Subject: MonoBehaviour
    {
        private readonly ArrayList m_observers = new ArrayList();

        // 옵저버 목록에 옵저버 객체를 추가한다.
        public void Attach(Observer observer)
        {
            m_observers.Add(observer);
        }

        // 옵저버 목록에서 옵저버 객체를 제거한다.
        public void Detach(Observer observer)
        {
            m_observers.Remove(observer);
        }

        // 옵저버 객체의 목록을 돌며 Notify()를 호출한다.
        public void NotifyObservers()
        {
            foreach (Observer observer in m_observers)
                observer.Notify(this);
        }
    }
}
```
<br></br>

* Observer 추상 클래스를 구현한다.
> Observer.cs
```C#
using UnityEngine;

namespace _Observer
{
    // 옵저버가 되고자 하는 클래스는 Observer 클래스를 상속받아 Notify()를 구현해야 한다.
    public abstract class Observer: MonoBehaviour
    {
        public abstract void Notify(Subject subject);
    }
}
```
<br></br>

* 핵심 구성 요소가 있으니 주체로 행동할 PlayerCtrl의 스켈레톤 코드를 작성한다.
> PlayerCtrl.cs
```C#
using UnityEngine;

namespace _Observer
{
    public class PlayerCtrl: Subject
    {
        // 초기화 부분
        //===========================================================================
        public bool IsTurboOn
        {
            get; private set;
        }

        public float CurrentHealth
        {
            get{ return m_health; }
        }

        private bool m_is_engine_on;
        private HUDCtrl m_hud_ctrl;
        private CameraCtrl m_camera_ctrl;

        [SerializeField]
        private float m_health = 100.0f;

        void Awake()
        {
            m_hud_ctrl = gameObject.AddComponent<HUDCtrl>();
            m_camera_ctrl = (CameraCtrl) FindObjectOfType(typeof(CameraCtrl));
        }

        private void Start()
        {
            StartEngine();
        }
        //===========================================================================

        // PlayerCtrl이 활성화될 때 관찰자를 연결하고 비활성화될 때 연결을 끊는 부분
        //===========================================================================
        void OnEnable()
        {
            if(m_hud_ctrl)
                Attach(m_hud_ctrl);

            if(m_camera_ctrl)
                Attach(m_camera_ctrl);
        }

        void OnDisable()
        {
            if(m_hud_ctrl)
                Detach(m_hud_ctrl);

            if(m_camera_ctrl)
                Detach(m_camera_ctrl);
        }
        //===========================================================================

        // 자전거의 파라미터가 업데이트되면 관찰자에게 알리는 부분
        //===========================================================================
        // NotifyObservers()를 호출 함으로 해야 할 동작 대신 바뀐 것이 있다는 정도만 알린다.
        private void StartEngine()
        {
            m_is_engine_on = true;
            NotifyObservers();
        }

        public void ToggleTurbo()
        {
            if(m_is_engine_on)
                m_is_turbo_on = !m_is_turbo_on;
            
            NotifyObservers();
        }

        public void TakeDamage(float amount)
        {
            m_health -= amount;
            m_is_turbo_on = false;

            NotifyObservers();

            if(m_health < 0)
                Destroy(gameObject);
        }
        //===========================================================================
    }
}
```
<br></br>

* 이제 관찰자를 구현하고 주체가 신호를 보낼 때 어떻게 행동하는지 살펴보자.
> HUDCtrl.cs
```C#
using UnityEngine;

namespace _Observer
{
    public class HUDCtrl: Observer
    {
        private bool m_is_turbo_on;
        private float m_current_health;
        private PlayerCtrl m_player_ctrl;

        private OnGUI()
        {
            GUILayout.BeginArea(new Rect(50, 50, 100, 200));
            GUILayout.BeginHorizontal("box");
            GUILayout.Label("Health: " + m_current_health);
            GUILayout.EndHorizontal();

            if(m_is_turbo_on)
            {
                GUILayout.BeginHorizontal("box");
                GUILayout.Label("Turbo Activated!");
                GUILayout.EndHorizontal();
            }

            if(m_current_health <= 50.0f)
            {
                GUILayout.BeginHorizontal("box");
                GUILayout.Label("WARNING: Low Health");
                GUILayout.EndHorizontal();
            }

            GUILayout.EndArea();
        }

        public override void Notify(Subject subject)
        {
            if(!m_player_ctrl)
                m_player_ctrl = subject.GetComponent<PlayerCtrl>();

            if(m_player_ctrl)
            {
                m_is_turbo_on = m_player_ctrl.m_is_turbo_on;
                m_current_health = m_player_ctrl.m_current_health;
            }
        }
    }
}
```
<br></br>

* 마지막으로 CameraCtrl을 구현한다. 카메라는 터보 부스터가 활성화됐을 때 흔들리기 시작한다.
> CameraCtrl.cs
```C#
using UnityEngine;

namespace _Observer
{
    public class CameraCtrl: Observer
    {
        private bool m_is_turbo_on;
        private Vector3 m_initial_position;
        private float m_shake_magnitude = 0.1f;
        private PlayerCtrl m_player_ctrl;

        void OnEnable()
        {
            m_initial_position = gameObject.transform.localPosition;
        }

        void Update()
        {
            // 참이라면 PlayerCtrl에서 알림을 다시 받고 터보 토글이 꺼진 것을 확인할 때까지 카메라가 흔들린다.
            if(m_is_turbo_on)
                gameObject.transform.localPosition = 
                        m_initial_position + (Random.insideUnitSphere + m_shake_magnitude);
            else
                gameObject.transform.localPosition = m_initial_position;
        }

        public override void Notify(Subject subject)
        {
            if(!m_player_ctrl)
                m_player_ctrl = subject.GetComponent<PlayerCtrl>();

            if(m_player_ctrl)
                m_is_turbo_on = m_player_ctrl.m_is_turbo_on;
        }
    }
}
```
<br></br>

* 옵저버 패턴 구현 코드를 확인한다.
> ClientObserver.cs
```C#
using UnityEngine;

namespace _Observer
{
    public class ClientObserver: MonoBehaviour
    {
        private PlayerCtrl m_player_ctrl;

        private void Start()
        {
            m_player_ctrl = (PlayerCtrl)FindObjectOfType(typeof(PlayerCtrl));
        }

        private void OnGUI()
        {
            if(GUILayout.Button("Damage Player"))
                if(m_player_ctrl)
                    m_player_ctrl.TakeDamage(15.0f);
            
            if(GUILayout.Button("Toggle Turbo"))
                if(m_player_ctrl)
                    m_player_ctrl.ToggleTurbo();
        }
    }
}